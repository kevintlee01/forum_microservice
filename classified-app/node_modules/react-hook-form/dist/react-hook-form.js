'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

var isCheckBoxInput = (type) => type === 'checkbox';

function attachEventListeners({ field, validateAndStateUpdate, isRadio, }) {
    const { ref } = field;
    if (!ref.addEventListener)
        return;
    ref.addEventListener(isCheckBoxInput(ref.type) || isRadio ? 'change' : 'input', validateAndStateUpdate);
    ref.addEventListener('blur', validateAndStateUpdate);
}

var isObject = (value) => value !== null && !Array.isArray(value) && typeof value === 'object';

const reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
const reIsPlainProp = /^\w*$/;
const rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
const reEscapeChar = /\\(\\)?/g;
const reIsUint = /^(?:0|[1-9]\d*)$/;
const isArray = Array.isArray;
function isIndex(value) {
    return reIsUint.test(value) && value > -1;
}
function isKey(value) {
    if (isArray(value))
        return false;
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value);
}
const stringToPath = (string) => {
    const result = [];
    string.replace(rePropName, (match, number, quote, string) => {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
};
function set(object, path, value) {
    const tempPath = isKey(path) ? [path] : stringToPath(path);
    let index = -1;
    const length = tempPath.length;
    const lastIndex = length - 1;
    while (++index < length) {
        const key = tempPath[index];
        let newValue = value;
        if (index !== lastIndex) {
            const objValue = object[key];
            newValue =
                isObject(objValue) || isArray(objValue)
                    ? objValue
                    : isIndex(tempPath[index + 1])
                        ? []
                        : {};
        }
        object[key] = newValue;
        object = object[key];
    }
    return object;
}

var combineFieldValues = (data) => Object.entries(data).reduce((previous, [key, value]) => {
    if (key.match(/\[\d+\]/gi) || key.indexOf('.')) {
        set(previous, key, value);
        return previous;
    }
    return Object.assign({}, previous, { [key]: value });
}, {});

var removeAllEventListeners = (ref, validateWithStateUpdate) => {
    if (!ref.removeEventListener)
        return;
    ref.removeEventListener('input', validateWithStateUpdate);
    ref.removeEventListener('change', validateWithStateUpdate);
    ref.removeEventListener('blur', validateWithStateUpdate);
};

var isRadioInput = (type) => type === 'radio';

function isDetached(element) {
    // falsy elements are detached (probably a null parent)
    if (!element)
        return true;
    // Non HTML Elements should never be considered detached
    // If we can find our way up to a document node, we assume we are still attached!
    if (!(element instanceof HTMLElement) ||
        element.nodeType === Node.DOCUMENT_NODE)
        return false;
    // Recursive call
    return isDetached(element.parentNode);
}

function findRemovedFieldAndRemoveListener(fields, validateWithStateUpdate = () => { }, { ref, mutationWatcher, options }, forceDelete = false) {
    if (!ref || !ref.type)
        return;
    const { name, type } = ref;
    if (isRadioInput(type) && options) {
        options.forEach(({ ref }, index) => {
            if (options[index] && isDetached(ref) || forceDelete) {
                removeAllEventListeners(options[index], validateWithStateUpdate);
                (options[index].mutationWatcher || { disconnect: () => { } }).disconnect();
                options.splice(index, 1);
            }
        });
        if (!options.length)
            delete fields[name];
    }
    else if (isDetached(ref) || forceDelete) {
        removeAllEventListeners(ref, validateWithStateUpdate);
        if (mutationWatcher)
            mutationWatcher.disconnect();
        delete fields[name];
    }
}

const defaultReturn = {
    isValid: false,
    value: '',
};
function getRadioValue(options) {
    return Array.isArray(options)
        ? options.reduce((previous, { ref: { checked, value } }) => checked
            ? {
                isValid: true,
                value,
            }
            : previous, defaultReturn)
        : defaultReturn;
}

var getMultipleSelectValue = (options) => [...options].filter(({ selected }) => selected).map(({ value }) => value);

function getFieldValue(fields, ref) {
    const { type, name, options, checked, value } = ref;
    if (isRadioInput(type)) {
        const field = fields[name];
        return field ? getRadioValue(field.options).value : '';
    }
    if (type === 'select-multiple')
        return getMultipleSelectValue(options);
    if (isCheckBoxInput(type))
        return checked
            ? ref.attributes && ref.attributes.value
                ? value
                : true
            : false;
    return value;
}

var isString = (value) => typeof value === 'string';

function getFieldsValue(fields, fieldName) {
    return Object.values(fields).reduce((previous, { ref, ref: { name } }) => {
        const value = getFieldValue(fields, ref);
        if (isString(fieldName))
            return name === fieldName ? value : previous;
        if (!fieldName) {
            previous[name] = value;
        }
        else if (Array.isArray(fieldName) && fieldName.includes(name)) {
            previous[name] = value;
        }
        return previous;
    }, {});
}

var isEmptyObject = (value) => isObject(value) && Object.keys(value).length === 0;

function shouldUpdateWithError({ errors, name, error, isOnBlur, isBlurType, isValidateDisabled, }) {
    if (isValidateDisabled ||
        (isOnBlur && !isBlurType) ||
        (isEmptyObject(error) && isEmptyObject(errors)) ||
        (errors[name] && errors[name].isManual)) {
        return false;
    }
    if ((isEmptyObject(errors) && !isEmptyObject(error)) ||
        (isEmptyObject(error) && errors[name]) ||
        !errors[name]) {
        return true;
    }
    return (errors[name] &&
        error[name] &&
        (errors[name].type !== error[name].type ||
            errors[name].message !== error[name].message));
}

var isUndefined = (val) => val === undefined;

var isNullOrUndefined = (value) => value === null || isUndefined(value);

var getValueAndMessage = (item) => ({
    value: isObject(item) && !isNullOrUndefined(item.value) ? item.value : item,
    message: isObject(item) && item.message ? item.message : '',
});

var displayNativeError = (nativeValidation, ref, message) => {
    if (nativeValidation && isString(message))
        ref.setCustomValidity(message);
};

const DATE_INPUTS = [
    'date',
    'time',
    'month',
    'datetime',
    'datetime-local',
    'week',
];
const STRING_INPUTS = [
    'text',
    'email',
    'password',
    'search',
    'tel',
    'url',
    'textarea',
];
const VALIDATION_MODE = {
    onBlur: 'onBlur',
    onChange: 'onChange',
    onSubmit: 'onSubmit',
};

var isFunction = (value) => typeof value === 'function';

var isBoolean = (value) => typeof value === 'boolean';

var validateField = async ({ ref, ref: { type, value, name, checked }, options, required, maxLength, minLength, min, max, pattern, validate, }, fields, nativeValidation) => {
    const error = {};
    const isRadio = isRadioInput(type);
    const isCheckBox = isCheckBoxInput(type);
    const isSelectOrInput = !isCheckBox && !isRadio;
    const nativeError = displayNativeError.bind(null, nativeValidation, ref);
    const isStringInput = STRING_INPUTS.includes(type) || isString(value);
    if (required &&
        ((isCheckBox && !checked) ||
            (isSelectOrInput && value === '') ||
            (isRadio && !getRadioValue(fields[name].options).isValid) ||
            (!type && !value))) {
        error[name] = {
            type: 'required',
            message: isString(required) ? required : '',
            ref: isRadio ? (fields[name].options || [{ ref: '' }])[0].ref : ref,
        };
        nativeError(required);
        return error;
    }
    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {
        let exceedMax;
        let exceedMin;
        const valueNumber = parseFloat(value);
        const { value: maxValue, message: maxMessage } = getValueAndMessage(max);
        const { value: minValue, message: minMessage } = getValueAndMessage(min);
        if (type === 'number' || !isNaN(value)) {
            exceedMax = !isNullOrUndefined(maxValue) && valueNumber > maxValue;
            exceedMin = !isNullOrUndefined(minValue) && valueNumber < minValue;
        }
        else if (DATE_INPUTS.includes(type) || type === undefined) {
            if (isString(maxValue))
                exceedMax = maxValue && new Date(value) > new Date(maxValue);
            if (isString(minValue))
                exceedMin = minValue && new Date(value) < new Date(minValue);
        }
        if (exceedMax || exceedMin) {
            const message = exceedMax ? maxMessage : minMessage;
            error[name] = {
                type: exceedMax ? 'max' : 'min',
                message,
                ref,
            };
            nativeError(message);
            return error;
        }
    }
    if ((maxLength || minLength) && isStringInput) {
        const { value: maxLengthValue, message: maxLengthMessage, } = getValueAndMessage(maxLength);
        const { value: minLengthValue, message: minLengthMessage, } = getValueAndMessage(minLength);
        const inputLength = value.toString().length;
        const exceedMax = maxLength && inputLength > maxLengthValue;
        const exceedMin = inputLength && minLength && inputLength < minLengthValue;
        const message = exceedMax ? maxLengthMessage : minLengthMessage;
        if (exceedMax || exceedMin) {
            error[name] = {
                type: exceedMax ? 'maxLength' : 'minLength',
                message,
                ref,
            };
            nativeError(message);
            return error;
        }
    }
    if (pattern) {
        const { value: patternValue, message: patternMessage } = getValueAndMessage(pattern);
        if (patternValue instanceof RegExp && !patternValue.test(value)) {
            error[name] = {
                type: 'pattern',
                message: patternMessage,
                ref,
            };
            nativeError(patternMessage);
            return error;
        }
    }
    if (validate) {
        const fieldValue = isRadio ? getRadioValue(options).value : value;
        const validateRef = isRadio && options ? options[0].ref : ref;
        if (isFunction(validate)) {
            const result = await validate(fieldValue);
            if ((isString(result) && result) || (isBoolean(result) && !result)) {
                error[name] = {
                    type: 'validate',
                    message: isString(result) ? result : '',
                    ref: validateRef,
                };
                nativeError(result);
                return error;
            }
        }
        else if (isObject(validate)) {
            const validationResult = await new Promise((resolve) => {
                const values = Object.entries(validate);
                values.reduce(async (previous, [key, validate], index) => {
                    const lastChild = values.length - 1 === index;
                    if (isFunction(validate)) {
                        const result = await validate(fieldValue);
                        if (!isBoolean(result) || !result) {
                            const message = isString(result) ? result : '';
                            const data = {
                                type: key,
                                message,
                                ref: validateRef,
                            };
                            nativeError(message);
                            return lastChild ? resolve(data) : data;
                        }
                    }
                    return lastChild ? resolve(previous) : previous;
                }, {});
            });
            if (validationResult && !isEmptyObject(validationResult)) {
                error[name] = Object.assign({ ref: validateRef }, validationResult);
                return error;
            }
        }
    }
    if (nativeValidation)
        ref.setCustomValidity('');
    return error;
};

function parseErrorSchema(error) {
    return error.inner.reduce((previous, { path, message, type }) => (Object.assign({}, previous, { [path]: { message, ref: {}, type } })), {});
}
async function validateWithSchema(ValidationSchema, data) {
    try {
        return {
            result: await ValidationSchema.validate(data, { abortEarly: false }),
            fieldErrors: {},
        };
    }
    catch (e) {
        return {
            fieldErrors: parseErrorSchema(e),
            result: {},
        };
    }
}

function attachNativeValidation(ref, rules) {
    Object.entries(rules).forEach(([key, value]) => {
        if (key === 'pattern' && value instanceof RegExp) {
            ref[key] = value.source;
        }
        else {
            ref[key] = key === 'required' ? true : value;
        }
    });
}

function get(object, keys, defaultVal) {
    keys = Array.isArray(keys)
        ? keys
        : keys
            .replace(/\[/g, '.')
            .replace(/\]/g, '')
            .split('.');
    object = object[keys[0]];
    return object && keys.length > 1
        ? get(object, keys.slice(1), defaultVal)
        : isUndefined(object)
            ? defaultVal
            : object;
}

var getDefaultValue = (defaultValues, name) => defaultValues && (defaultValues[name] || get(defaultValues, name));

function flatArray(list) {
    return list.reduce((a, b) => a.concat(Array.isArray(b) ? flatArray(b) : b), []);
}

const getPath = (path, values) => Array.isArray(values)
    ? values.map((item, index) => {
        const pathWithIndex = `${path}[${index}]`;
        if (Array.isArray(item)) {
            return getPath(pathWithIndex, item);
        }
        else if (isObject(item)) {
            return Object.entries(item).map(([key, objectValue]) => isString(objectValue)
                ? `${pathWithIndex}.${key}`
                : getPath(`${pathWithIndex}.${key}`, objectValue));
        }
        return pathWithIndex;
    })
    : Object.entries(values).map(([key, objectValue]) => isString(objectValue) ? `${path}.${key}` : getPath(path, objectValue));
var getPath$1 = (parentPath, value) => flatArray(getPath(parentPath, value));

var assignWatchFields = (fieldValues, fieldName, watchFields) => {
    if (isEmptyObject(fieldValues) || isUndefined(fieldValues))
        return undefined;
    if (!isUndefined(fieldValues[fieldName])) {
        watchFields[fieldName] = true;
        return fieldValues[fieldName];
    }
    const combinedValues = combineFieldValues(fieldValues);
    const values = get(combinedValues, fieldName);
    if (values !== undefined) {
        const result = getPath$1(fieldName, values);
        if (Array.isArray(result)) {
            result.forEach(name => {
                watchFields[name] = true;
            });
        }
    }
    return values;
};

function onDomRemove(element, onDetachCallback) {
    const observer = new MutationObserver(() => {
        if (isDetached(element)) {
            observer.disconnect();
            onDetachCallback();
        }
    });
    observer.observe(window.document, {
        childList: true,
        subtree: true,
    });
    return observer;
}

var modeChecker = (mode) => ({
    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
    isOnBlur: mode === VALIDATION_MODE.onBlur,
    isOnChange: mode === VALIDATION_MODE.onChange,
});

var warnMessage = (message) => {
    if (process.env.NODE_ENV !== 'production')
        console.warn(message);
};

var omitValidFields = (errorFields, validFieldNames) => Object.entries(errorFields).reduce((previous, [name, error]) => validFieldNames.some(validFieldName => validFieldName === name)
    ? previous
    : Object.assign({}, previous, { [name]: error }), {});

function useForm({ mode = VALIDATION_MODE.onSubmit, validationSchema, defaultValues = {}, validationFields, nativeValidation, submitFocusError = true, } = {}) {
    const fieldsRef = React.useRef({});
    const errorsRef = React.useRef({});
    const schemaErrorsRef = React.useRef({});
    const submitCountRef = React.useRef(0);
    const touchedFieldsRef = React.useRef(new Set());
    const watchFieldsRef = React.useRef({});
    const isUnMount = React.useRef(false);
    const isWatchAllRef = React.useRef(false);
    const isSubmittingRef = React.useRef(false);
    const isSubmittedRef = React.useRef(false);
    const isDirtyRef = React.useRef(false);
    const isSchemaValidateTriggeredRef = React.useRef(false);
    const validateAndStateUpdateRef = React.useRef();
    const fieldsWithValidationRef = React.useRef(new Set());
    const validFieldsRef = React.useRef(new Set());
    const [, reRenderForm] = React.useState({});
    const { isOnChange, isOnBlur, isOnSubmit } = React.useRef(modeChecker(mode)).current;
    const combineErrorsRef = (data) => (Object.assign({}, errorsRef.current, data));
    const renderBaseOnError = React.useCallback((name, errorsFromRef, error, shouldRender = true) => {
        if (errorsFromRef[name] && !error[name]) {
            delete errorsRef.current[name];
            validFieldsRef.current.add(name);
            if (shouldRender)
                reRenderForm({});
            return true;
        }
        else if (error[name]) {
            validFieldsRef.current.delete(name);
            if (shouldRender)
                reRenderForm({});
            return true;
        }
        if (!isOnSubmit && !validFieldsRef.current.has(name)) {
            validFieldsRef.current.add(name);
            if (shouldRender)
                reRenderForm({});
            return true;
        }
        return false;
    }, [isOnSubmit]);
    const setFieldValue = (name, value) => {
        const field = fieldsRef.current[name];
        if (!field)
            return;
        const ref = field.ref;
        const options = field.options;
        if (isRadioInput(ref.type) && options) {
            options.forEach(({ ref: radioRef }) => {
                if (radioRef.value === value)
                    radioRef.checked = true;
            });
        }
        else {
            ref[isCheckBoxInput(ref.type) ? 'checked' : 'value'] = value;
        }
    };
    const setValueInternal = React.useCallback((name, value) => {
        setFieldValue(name, value);
        touchedFieldsRef.current.add(name);
        isDirtyRef.current = true;
        reRenderForm({});
    }, []);
    const executeValidation = React.useCallback(async ({ name, value, }, shouldRender = true) => {
        const field = fieldsRef.current[name];
        const errors = errorsRef.current;
        if (!field)
            return false;
        if (value !== undefined)
            setValueInternal(name, value);
        const error = await validateField(field, fieldsRef.current);
        errorsRef.current = combineErrorsRef(error);
        renderBaseOnError(name, errors, error, shouldRender);
        return isEmptyObject(error);
    }, [renderBaseOnError, setValueInternal]);
    const executeSchemaValidation = React.useCallback(async (payload) => {
        const { fieldErrors } = await validateWithSchema(validationSchema, combineFieldValues(getFieldsValue(fieldsRef.current)));
        const names = Array.isArray(payload)
            ? payload.map(({ name }) => name)
            : [payload.name];
        const validFieldNames = names.filter(name => !fieldErrors[name]);
        const skipNamesOmittedInPayload = ([key]) => names.includes(key);
        schemaErrorsRef.current = fieldErrors;
        errorsRef.current = omitValidFields(combineErrorsRef(Object.entries(fieldErrors)
            .filter(skipNamesOmittedInPayload)
            .reduce((previous, [name, error]) => (Object.assign({}, previous, { [name]: error })), {})), validFieldNames);
        isSchemaValidateTriggeredRef.current = true;
        reRenderForm({});
        return isEmptyObject(errorsRef.current);
    }, [validationSchema]);
    const triggerValidation = React.useCallback(async (payload) => {
        let fields = payload;
        if (!payload)
            fields = Object.keys(fieldsRef.current).map(name => ({ name }));
        if (validationSchema)
            return executeSchemaValidation(fields);
        if (Array.isArray(fields)) {
            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, false)));
            reRenderForm({});
            return result.every(Boolean);
        }
        return await executeValidation(fields);
    }, [executeSchemaValidation, executeValidation, validationSchema]);
    const setValue = React.useCallback((name, value, shouldValidate = false) => {
        setValueInternal(name, value);
        if (shouldValidate)
            triggerValidation({ name });
    }, [setValueInternal, triggerValidation]);
    validateAndStateUpdateRef.current = validateAndStateUpdateRef.current
        ? validateAndStateUpdateRef.current
        : async ({ target: { name }, type }) => {
            if (Array.isArray(validationFields) && !validationFields.includes(name))
                return;
            const fields = fieldsRef.current;
            const errorsFromRef = errorsRef.current;
            const ref = fields[name];
            if (!ref)
                return;
            const isBlurType = type === 'blur';
            const isValidateDisabled = !isSubmittedRef.current && isOnSubmit;
            const shouldUpdateValidateMode = isOnChange || (isOnBlur && isBlurType);
            let shouldUpdateState = isWatchAllRef.current || watchFieldsRef.current[name];
            if (!isDirtyRef.current) {
                isDirtyRef.current = true;
                shouldUpdateState = true;
            }
            if (!touchedFieldsRef.current.has(name)) {
                touchedFieldsRef.current.add(name);
                shouldUpdateState = true;
            }
            if (isValidateDisabled && shouldUpdateState)
                return reRenderForm({});
            if (validationSchema) {
                const { fieldErrors } = await validateWithSchema(validationSchema, combineFieldValues(getFieldsValue(fields)));
                schemaErrorsRef.current = fieldErrors;
                isSchemaValidateTriggeredRef.current = true;
                const error = fieldErrors[name];
                const shouldUpdate = ((!error && errorsFromRef[name]) || error) &&
                    (shouldUpdateValidateMode || isSubmittedRef.current);
                if (shouldUpdate) {
                    errorsRef.current = Object.assign({}, errorsFromRef, { [name]: error });
                    if (!error)
                        delete errorsRef.current[name];
                    return reRenderForm({});
                }
            }
            else {
                const error = await validateField(ref, fields, nativeValidation);
                const shouldUpdate = shouldUpdateWithError({
                    errors: errorsFromRef,
                    error,
                    isValidateDisabled,
                    isOnBlur,
                    isBlurType,
                    name,
                });
                if (shouldUpdate || shouldUpdateValidateMode) {
                    errorsRef.current = combineErrorsRef(error);
                    if (renderBaseOnError(name, errorsRef.current, error))
                        return;
                }
            }
            if (shouldUpdateState)
                reRenderForm({});
        };
    const resetFieldRef = (name) => {
        delete watchFieldsRef.current[name];
        delete errorsRef.current[name];
        delete fieldsRef.current[name];
        touchedFieldsRef.current.delete(name);
        fieldsWithValidationRef.current.delete(name);
        validFieldsRef.current.delete(name);
    };
    const removeEventListenerAndRef = React.useCallback((field, forceDelete) => {
        findRemovedFieldAndRemoveListener(fieldsRef.current, validateAndStateUpdateRef.current, field, forceDelete);
        if (field.ref)
            resetFieldRef(field.ref.name);
    }, []);
    const clearError = (name) => {
        if (name === undefined) {
            errorsRef.current = {};
        }
        else if (isString(name)) {
            delete errorsRef.current[name];
        }
        else if (Array.isArray(name)) {
            name.forEach(item => {
                delete errorsRef.current[item];
            });
        }
        reRenderForm({});
    };
    const setError = (name, type, message, ref) => {
        const errorsFromRef = errorsRef.current;
        const error = errorsFromRef[name];
        const isSameError = error &&
            !isString(error) &&
            (error.type === type && error.message === message);
        if (!isSameError) {
            errorsFromRef[name] = {
                type,
                message,
                ref,
                isManual: true,
            };
            reRenderForm({});
        }
    };
    const registerIntoFieldsRef = React.useCallback((elementRef, data) => {
        if (elementRef && !elementRef.name)
            return warnMessage(`⚠ Missing field name: ${elementRef}`);
        const { name, type, value } = elementRef;
        if (!isOnSubmit && data && !isEmptyObject(data)) {
            fieldsWithValidationRef.current.add(name);
        }
        const { required = false, validate = undefined } = data || {};
        const inputData = Object.assign({}, data, { ref: elementRef });
        const fields = fieldsRef.current;
        const isRadio = isRadioInput(type);
        const field = fields[name];
        const existRadioOptionIndex = isRadio && field && Array.isArray(field.options)
            ? field.options.findIndex(({ ref }) => value === ref.value)
            : -1;
        if ((!isRadio && field) || (isRadio && existRadioOptionIndex > -1))
            return;
        if (!type) {
            fields[name] = Object.assign({ ref: { name } }, data);
        }
        else {
            if (isRadio) {
                if (!field)
                    fields[name] = {
                        options: [],
                        required,
                        validate,
                        ref: { type: 'radio', name },
                    };
                if (validate)
                    fields[name].validate = validate;
                (fields[name].options || []).push(Object.assign({}, inputData, { mutationWatcher: onDomRemove(elementRef, () => removeEventListenerAndRef(inputData)) }));
            }
            else {
                fields[name] = Object.assign({}, inputData, { mutationWatcher: onDomRemove(elementRef, () => removeEventListenerAndRef(inputData)) });
            }
        }
        if (defaultValues) {
            const defaultValue = defaultValues[name] || get(defaultValues, name);
            if (defaultValue !== undefined)
                setFieldValue(name, defaultValue);
        }
        if (!type)
            return;
        const fieldData = isRadio
            ? (fields[name].options || [])[(fields[name].options || []).length - 1]
            : fields[name];
        if (!fieldData)
            return;
        if (nativeValidation && data) {
            attachNativeValidation(elementRef, data);
        }
        else {
            attachEventListeners({
                field: fieldData,
                isRadio,
                validateAndStateUpdate: validateAndStateUpdateRef.current,
            });
        }
    }, [defaultValues, isOnSubmit, nativeValidation, removeEventListenerAndRef]);
    function watch(fieldNames, defaultValue) {
        const fieldValues = getFieldsValue(fieldsRef.current);
        const watchFields = watchFieldsRef.current;
        if (isString(fieldNames)) {
            const value = assignWatchFields(fieldValues, fieldNames, watchFields);
            if (!isUndefined(value)) {
                return value;
            }
            else if (!isUndefined(defaultValue)) {
                return defaultValue;
            }
            return getDefaultValue(defaultValues, fieldNames);
        }
        if (Array.isArray(fieldNames)) {
            return isEmptyObject(fieldsRef.current)
                ? fieldNames.reduce((previous, name) => (Object.assign({}, previous, { [name]: !isUndefined(defaultValue) && !isString(defaultValue)
                        ? defaultValue[name]
                        : defaultValues
                            ? defaultValues[name] || get(defaultValues, name)
                            : undefined })), {})
                : fieldNames.reduce((previous, name) => (Object.assign({}, previous, { [name]: assignWatchFields(fieldValues, name, watchFields) ||
                        getDefaultValue(defaultValues, name) })), {});
        }
        isWatchAllRef.current = true;
        return ((isEmptyObject(fieldValues) ? undefined : fieldValues) ||
            defaultValue ||
            defaultValues);
    }
    const register = React.useCallback((refOrValidateRule, validateRule) => {
        if (!refOrValidateRule || typeof window === 'undefined')
            return;
        if (validateRule && !refOrValidateRule.name) {
            warnMessage(refOrValidateRule);
            return;
        }
        if (refOrValidateRule.name) {
            registerIntoFieldsRef(refOrValidateRule, validateRule);
        }
        return (ref) => ref && registerIntoFieldsRef(ref, refOrValidateRule);
    }, [registerIntoFieldsRef]);
    function unregister(names) {
        if (isEmptyObject(fieldsRef.current))
            return;
        (Array.isArray(names) ? names : [names]).forEach(fieldName => removeEventListenerAndRef(fieldsRef.current[fieldName], true));
    }
    const handleSubmit = (callback) => async (e) => {
        if (e) {
            e.preventDefault();
            e.persist();
        }
        let fieldErrors;
        let fieldValues;
        let firstFocusError = true;
        const fields = fieldsRef.current;
        const fieldsToValidate = validationFields
            ? validationFields.map(name => fieldsRef.current[name])
            : Object.values(fields);
        isSubmittingRef.current = true;
        reRenderForm({});
        if (validationSchema) {
            fieldValues = getFieldsValue(fields);
            const output = await validateWithSchema(validationSchema, combineFieldValues(fieldValues));
            schemaErrorsRef.current = output.fieldErrors;
            fieldErrors = output.fieldErrors;
            fieldValues = output.result;
        }
        else {
            const { errors, values, } = await fieldsToValidate.reduce(async (previous, field) => {
                if (!field)
                    return previous;
                const resolvedPrevious = await previous;
                const { ref, ref: { name }, } = field;
                if (!fields[name])
                    return Promise.resolve(resolvedPrevious);
                const fieldError = await validateField(field, fields, nativeValidation);
                if (fieldError[name]) {
                    if (submitFocusError && firstFocusError && ref.focus) {
                        ref.focus();
                        firstFocusError = false;
                    }
                    resolvedPrevious.errors = Object.assign({}, resolvedPrevious.errors, fieldError);
                    return Promise.resolve(resolvedPrevious);
                }
                resolvedPrevious.values[name] = getFieldValue(fields, ref);
                return Promise.resolve(resolvedPrevious);
            }, Promise.resolve({
                errors: {},
                values: {},
            }));
            fieldErrors = errors;
            fieldValues = values;
        }
        if (isEmptyObject(fieldErrors)) {
            errorsRef.current = {};
            await callback(combineFieldValues(fieldValues), e);
        }
        else {
            errorsRef.current = fieldErrors;
        }
        if (isUnMount.current)
            return;
        isSubmittedRef.current = true;
        submitCountRef.current += 1;
        isSubmittingRef.current = false;
        reRenderForm({});
    };
    const resetRefs = () => {
        watchFieldsRef.current = {};
        errorsRef.current = {};
        isWatchAllRef.current = false;
        isSubmittedRef.current = false;
        isDirtyRef.current = false;
        touchedFieldsRef.current = new Set();
        fieldsWithValidationRef.current = new Set();
        validFieldsRef.current = new Set();
        submitCountRef.current = 0;
        isSchemaValidateTriggeredRef.current = false;
    };
    const unSubscribe = React.useCallback(() => {
        fieldsRef.current &&
            Object.values(fieldsRef.current).forEach((field) => removeEventListenerAndRef(field, true));
        fieldsRef.current = {};
        resetRefs();
    }, [removeEventListenerAndRef]);
    const reset = React.useCallback((values) => {
        const fields = fieldsRef.current;
        const fieldsKeyValue = Object.entries(fields);
        for (let [, value] of fieldsKeyValue) {
            if (value && value.ref && value.ref.closest) {
                try {
                    value.ref.closest('form').reset();
                    break;
                }
                catch (_a) { }
            }
        }
        resetRefs();
        if (values) {
            fieldsKeyValue.forEach(([key]) => {
                setFieldValue(key, get(values, key, ''));
            });
        }
        reRenderForm({});
    }, []);
    const getValues = (payload) => {
        const data = getFieldsValue(fieldsRef.current);
        const output = payload && payload.nest ? combineFieldValues(data) : data;
        return isEmptyObject(output) ? defaultValues : output;
    };
    React.useEffect(() => () => {
        isUnMount.current = true;
        unSubscribe();
    }, [unSubscribe]);
    return {
        register,
        unregister: React.useCallback(unregister, [
            unregister,
            removeEventListenerAndRef,
        ]),
        handleSubmit,
        watch,
        reset,
        clearError,
        setError,
        setValue,
        triggerValidation,
        getValues,
        errors: errorsRef.current,
        formState: Object.assign({ dirty: isDirtyRef.current, isSubmitted: isSubmittedRef.current, submitCount: submitCountRef.current, touched: [...touchedFieldsRef.current], isSubmitting: isSubmittingRef.current }, (isOnSubmit
            ? {
                isValid: isEmptyObject(errorsRef.current),
            }
            : {
                isValid: validationSchema
                    ? isSchemaValidateTriggeredRef.current &&
                        isEmptyObject(schemaErrorsRef.current)
                    : fieldsWithValidationRef.current.size
                        ? !isEmptyObject(fieldsRef.current) &&
                            validFieldsRef.current.size >=
                                fieldsWithValidationRef.current.size
                        : !isEmptyObject(fieldsRef.current),
            })),
    };
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

const FormGlobalContext = React.createContext(null);
function useFormContext() {
    // @ts-ignore
    return React.useContext(FormGlobalContext);
}
function FormContext(props) {
    const { children } = props, rest = __rest(props, ["children"]);
    return (React.createElement(FormGlobalContext.Provider, { value: rest }, children));
}

exports.FormContext = FormContext;
exports.default = useForm;
exports.useFormContext = useFormContext;
